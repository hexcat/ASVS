# V4 API та вебсервіси

## Мета контролю

Існує низка міркувань, які стосуються саме застосунків, що надають APIs для використання веб-браузерами або іншими споживачами (зазвичай із використанням JSON, XML або GraphQL). У цьому розділі розглядаються відповідні механізми безпеки та конфігурації, які слід застосовувати.

Зверніть увагу, що питання автентифікації, управління сесіями та валідації вхідних даних, розглянуті в інших розділах, також стосуються API, тому цей розділ не слід розглядати окремо або перевіряти у відриві від загального контексту.

## V4.1 Загальна безпека вебсервісів

У цій секції розглядаються загальні питання безпеки вебсервісів і, відповідно, базові практики безпеки вебсервісів.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **4.1.1** | Перевірити, що кожна HTTP-відповідь з тілом повідомлення містить заголовок Content-Type, який відповідає фактичному вмісту відповіді, включно з параметром charset для вказівки безпечного кодування символів (наприклад, UTF-8, ISO-8859-1) згідно з IANA Media Types, таких як "text/", "/+xml" та "/xml". | 1 |
| **4.1.2** | Перевірити, що лише кінцеві точки, орієнтовані на користувача (передбачені для ручного доступу через веб-браузер), автоматично перенаправляють з HTTP на HTTPS, тоді як інші сервіси або кінцеві точки не реалізують прозорі перенаправлення. Це запобігає ситуації, коли клієнт помилково надсилає незашифровані HTTP-запити, але через автоматичне перенаправлення на HTTPS витік конфіденційних даних залишається непоміченим. | 2 |
| **4.1.3** | Перевірити, що будь-який HTTP-заголовок, який використовується застосунком і встановлюється проміжним шаром (наприклад, балансувальником навантаження, веб-проксі або backend-for-frontend сервісом), не може бути перевизначений кінцевим користувачем. Прикладами таких заголовків можуть бути X-Real-IP, X-Forwarded-*, або X-User-ID. | 2 |
| **4.1.4** | Перевірити, що можуть використовуватися лише HTTP-методи, які явно підтримуються застосунком або його API (включно з OPTIONS для preflight-запитів), а невикористовувані методи блокуються. | 3 |
| **4.1.5** | Перевірити, що для кожного повідомлення у випадку дуже чутливих запитів або транзакцій, які проходять через кілька систем, застосовуються цифрові підписи як додатковий рівень захисту поверх транспортних механізмів. | 3 |

## V4.2 Валідація структури HTTP-повідомлень

У цій секції пояснюється, як слід перевіряти структуру та заголовки HTTP-повідомлень, щоб запобігти атакам, таким як request smuggling, response splitting, header injection і відмова в обслуговуванні(DoS) через надмірно довгі HTTP-повідомлення.

Ці вимоги стосуються загальної обробки й формування HTTP-повідомлень, але мають особливе значення під час перетворення HTTP-повідомлень між різними версіями HTTP.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **4.2.1** | Перевірити, що всі компоненти застосунку (включно з балансувальниками навантаження, міжмережевими екранами та серверними додатками) визначають межі вхідних HTTP-повідомлень, використовуючи відповідний механізм для конкретної версії HTTP, щоб запобігти HTTP request smuggling. У HTTP/1.x, якщо присутнє поле заголовка Transfer-Encoding, поле Content-Length має ігноруватися відповідно до RFC 2616. При використанні HTTP/2 або HTTP/3, якщо присутнє поле Content-Length, приймач повинен переконатися, що його значення відповідає довжині DATA-кадрів. | 2 |
| **4.2.2** | Перевірити, що при формуванні HTTP-повідомлень поле заголовка Content-Length не суперечить довжині контенту, визначеній за фреймінгом HTTP-протоколу, щоб запобігти атакам типу request smuggling. | 3 |
| **4.2.3** | Перевірити, що застосунок не надсилає й не приймає HTTP/2 або HTTP/3 повідомлення з полями заголовка, специфічними для з'єднання, такими як Transfer-Encoding, щоб запобігти атакам типу response splitting та header injection. | 3 |
| **4.2.4** | Перевірити, що застосунок приймає лише HTTP/2 та HTTP/3 запити, у яких поля заголовків і їхні значення не містять жодних послідовностей CR (\r), LF (\n) або CRLF (\r\n), щоб запобігти атакам типу header injection. | 3 |
| **4.2.5** | Перевірити, що якщо застосунок (бекенд або фронтенд) формує та надсилає запити, він використовує валідацію, санітизацію або інші механізми, щоб уникнути створення URIs (таких як для викликів APIs) або полів заголовків HTTP-запиту (таких як Authorization або Cookie), які є надто довгими для прийняття приймаючим компонентом. Інакше це може спричинити відмову в обслуговуванні(DoS), наприклад, через надто довгий запит (наприклад, довге поле Cookie), через що сервер завжди повертає статус помилки. | 3 |

## V4.3 GraphQL

GraphQL стає дедалі популярнішим способом створення клієнтів з багатим набором даних, які не мають жорсткого зв’язку з різними бекенд-сервісами. У цьому розділі розглядаються питання безпеки, пов’язані з GraphQL.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **4.3.1** | Перевірити, що для запобігання у відмові в обслуговуванні (DoS), викликаній дорогими, вкладеними запитами у GraphQL або на рівні обробки виразів доступу до даних, використовується список дозволених запитів, обмеження глибини запиту, обмеження кількості запитів або аналіз вартості запиту. | 2 |
| **4.3.2** | Перевірити, що introspection-запити у GraphQL вимкнені в продуктивному середовищі, окрім випадку, коли GraphQL API призначений для використання іншими сторонами. | 2 |

## V4.4 WebSocket

WebSocket це протокол зв’язку, який забезпечує одночасний двонапрямлений канал передачі даних поверх одного TCP-з’єднання. Він був стандартизований IETF у 2011 році як RFC 6455 і відрізняється від HTTP, хоча й розроблений для роботи через HTTP-порти 443 та 80.

У цьому розділі наведено основні вимоги до безпеки, які необхідні для запобігання атакам, пов’язаним із безпекою передачі даних та керуванням сесіями, що спеціально експлуатують цей канал зв’язку в режимі реального часу.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **4.4.1** | Перевірити, що для всіх WebSocket-з’єднань використовується WebSocket поверх TLS (WSS). | 1 |
| **4.4.2** | Перевірити, що під час початкового HTTP WebSocket handshake поле заголовка Origin перевіряється за списком дозволених для застосунку джерел. | 2 |
| **4.4.3** | Перевірити, що якщо стандартне керування сесіями застосунку не може бути використане, застосовуються виділені токени, які відповідають відповідним вимогам безпеки керування сесіями. | 2 |
| **4.4.4** | Перевірити, що виділені токени керування сесіями WebSocket спочатку отримуються або проходять валідацію через попередньо автентифіковану HTTPS-сесію під час переходу існуючої HTTPS-сесії на WebSocket-канал. | 2 |

## Посилання

Для додаткової інформації дивіться також:

* [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)
* Ресурси з авторизації в GraphQL з [graphql.org](https://graphql.org/learn/authorization/) та [Apollo](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-methods).
* [OWASP Web Security Testing Guide: GraphQL Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL)
* [OWASP Web Security Testing Guide: Testing WebSockets](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets)
