# V1 Кодування та cанітизація

## Мета контролю

Цей розділ охоплює найпоширеніші вразливості безпеки веб-застосунків, які пов’язані з небезпечним опрацюванням недовірених даних. Такі вразливості можуть призводити до різноманітних технічних вразливостей, коли недовірені дані інтерпретуються відповідно до синтаксичних правил відповідного інтерпретатора.

Для сучасних веб-застосунків найкраще використовувати безпечні API, такі як параметризовані запити, автоматичне екранування або шаблонізовані фреймворки. В іншому випадку критичною для безпеки застосунку стає ретельна обробка вихідних даних: кодування, екранування або санітизація.

Валідація вхідних даних слугує механізмом багаторівневого захисту для запобігання небажаному або шкідливому вмісту. Однак, оскільки її основна мета це забезпечити відповідність вхідного вмісту функціональним та бізнес-вимогам, відповідні вимоги  які охоплюють цей аспект, наведені у розділі "Валідація та бізнес-логіка".

## V1.1 Архітектура кодування та санітизації

У наведених нижче підрозділах представлені вимоги, специфічні для певного синтаксису або інтерпретатора, щодо безпечної обробки небезпечного вмісту з метою уникнення вразливостей. Вимоги цього пыдрозділу охоплюють порядок, у якому має відбуватися така обробка, а також місце її виконання. Вони також спрямовані на забезпечення, що дані під час зберігання залишалися у своєму початковому вигляді і не зберігалися у закодованому чи екранованому форматі (наприклад, у вигляді HTML-кодування), щоб уникнути проблем з подвійним кодуванням.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **1.1.1** | Перевірити, що вхідні дані декодуються або розекрановуються у канонічну форму лише один раз, і декодування відбувається лише тоді, коли очікуються закодовані дані у цій формі, і що це виконується до подальшої обробки вхідних даних, зокрема не після валідації чи санітизації вхідних даних. | 2 |
| **1.1.2** | Перевірити, що застосунок виконує кодування та екранування вихідних даних або як фінальний крок перед використанням інтерпретатором, для якого вони призначені, або безпосередньо самим інтерпретатором. | 2 |

## V1.2 Запобігання ін’єкціям

Кодування або екранування вихідних даних, яке виконується безпосередньо в контексті, де існує потенційна загроза, є критично важливими для безпеки будь-якого застосунку. Зазвичай кодування та екранування не зберігаються, а застосовуються безпосередньо перед відображенням, щоб зробити вміст безпечним і готовим до миттєвого використання відповідним інтерпретатором. Занадто раннє виконання цих операцій може призвести до пошкодження вмісту або зробити кодування чи екранування неефективними.

Часто програмні бібліотеки містять безпечні або більш безпечні функції, які виконують це автоматично, проте необхідно переконатися, що вони правильно працюють у поточному контексті.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **1.2.1** | Перевірити, що кодування вихідних даних для HTTP-відповіді, HTML-документа або XML-документа відповідає необхідному контексту, такому як кодування відповідних символів для HTML-елементів, атрибутів HTML, HTML-коментарів, CSS або полів HTTP-заголовків, щоб уникнути зміни повідомлення або структури документа. | 1 |
| **1.2.2** | Перевірити, що при динамічному формуванні URL-адрес недовірені дані кодуються відповідно до їх контексту (наприклад, URL-кодування або base64url-кодування для параметрів запиту чи шляху). Забезпечити, щоб дозволялися лише безпечні протоколи URL (наприклад, заборонити javascript: або data:). | 1 |
| **1.2.3** | Перевірити, що кодування або екранування вихідних даних застосовується при динамічному формуванні JavaScript-вмісту (включно з JSON), щоб уникнути зміни структури повідомлення чи документа (щоб запобігти JavaScript- та JSON-ін’єкціям). | 1 |
| **1.2.4** | Перевірити, що для вибірки даних або запитів до бази даних (наприклад, SQL, HQL, NoSQL, Cypher) використовуються параметризовані запити, ORM, Entity Frameworks або інші методи захисту від SQL-ін’єкцій та інших атак на бази даних. Це також стосується написання збережених процедур. | 1 |
| **1.2.5** | Перевірити, що застосунок захищений від OS command injection та що виклики операційної системи здійснюються із використанням параметризованих запитів ОС або контекстного кодування виводу командного рядка. | 1 |
| **1.2.6** | Перевірити, що застосунок захищений від вразливостей LDAP-ін’єкції або що впроваджені конкретні заходи безпеки для запобігання LDAP-ін’єкції. | 2 |
| **1.2.7** | Перевірити, що застосунок захищений від атак XPath-ін’єкції шляхом використання параметризованих або попередньо cкомпільованих запитів. | 2 |
| **1.2.8** | Перевірити, що LaTeX-процесори налаштовані безпечно (наприклад, без використання прапорця "--shell-escape") та використовується список дозволених команд для запобігання атакам типу LaTeX-ін’єкції. | 2 |
| **1.2.9** | Перевірити, що застосунок екранує спеціальні символи в регулярних виразах (зазвичай за допомогою зворотного слеша), щоб запобігти їх некоректній інтерпретації як метасимволів. | 2 |
| **1.2.10** | Перевірити, що застосунок захищений від CSV-ін’єкцій та Formula Injection. Застосунок повинен дотримуватися правил екранування, визначених у розділах 2.6 і 2.7 RFC 4180 під час експорту у формат CSV. Крім того, при експорті у CSV або інші табличні формати (наприклад, XLS, XLSX, ODF) спеціальні символи (включно з '=', '+', '-', '@', '\t' (табуляція) та '\0' (нульовий символ)) повинні екрануватися одинарною лапкою, якщо вони є першим символом у значенні поля. | 3 |

Примітка: Використання параметризованих запитів або екранування SQL не завжди є достатнім. Частини запиту, такі як імена таблиць і стовпців (включно з іменами стовпців у "ORDER BY"), не можуть бути екрановані. Якщо у цих полях використовувати екрановані дані, отримані від користувача, це призведе до помилок у запитах або SQL-ін’єкцій.

## V1.3 Санітизація

Ідеальним захистом від використання недовіреного вмісту у небезпечному контексті є застосування контекстно-залежного кодування або екранування, яке зберігає семантичне значення таких даних, але робить їх безпечними для використання саме в цьому контексті, що детальніше описано у попередньому підрозділі.

Якщо це неможливо, тоді необхідна санітизація, видалення потенційно небезпечних символів або вмісту. У деяких випадках це може змінити семантичне значення вхідних даних, але з міркувань безпеки альтернативи може не бути.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **1.3.1** | Перевірити, що всі недовірені HTML дані із WYSIWYG редакторів або подібних джерел санітизуються з використанням відомої та безпечної бібліотеки або особливостей фреймворку для санітизації HTML. | 1 |
| **1.3.2** | Перевірити, що застосунок уникає використання eval() або інших засобів динамічного виконання коду, таких як Spring Expression Language (SpEL). Якщо іншого варіанту немає, будь-які дані користувача, які включені до виконання, мають бути санітизовані перед виконанням. | 1 |
| **1.3.3** | Перевірити, що дані, які передаються у потенційно небезпечний контекст, попередньо санітизовані для забезпечення заходів безпеки, зокрема допускати лише символи, безпечні для цього контексту, а також обрізати вхідні дані, які мають надмірну довжину. | 2 |
| **1.3.4** | Перевірити, що скриптовий вміст Scalable Vector Graphics (SVG), який наданий користувачем, проходить валідацію або санітизацію, щоб містити лише теги та атрибути (наприклад, для малювання графіки), які є безпечними для застосунку, зокрема, не містити скриптів і foreignObject. | 2 |
| **1.3.5** | Перевірити, що застосунок очищує або вимикає скриптовий вміст або вміст мов виразів і шаблонів, який наданий користувачем, наприклад Markdown, CSS або XSL-стилі, BBCode, чи подібні. | 2 |
| **1.3.6** | Перевірити, що застосунок захищений від атак Server-side Request Forgery (SSRF) шляхом валідації недовірених даних за списком дозволених протоколів, доменів, шляхів і портів, а також санітизація потенційно небезпечних символів перед використанням цих даних для виклику іншого сервісу. | 2 |
| **1.3.7** | Перевірити, що застосунок захищений від атак template injection, шляхом заорони створення шаблонів на основі недовірених вхідних даних. Якщо альтернативи немає, будь-які недовірені вхідні дані, які динамічно включаються під час створення шаблону, повинні бути санітизовані або суворо валідовані. | 2 |
| **1.3.8** | Перевірити, що застосунок належним чином санітизує недовірені вхідні дані перед використанням у запитах Java Naming and Directory Interface (JNDI) та що JNDI безпечно налаштовано для запобігання атакам JNDI injection. | 2 |
| **1.3.9** | Перевірити, що застосунок очищує вміст перед відправленням у memcache для запобігання атакам ін’єкцій. | 2 |
| **1.3.10** | Перевірити, що рядки форматування, які можуть розпізнаватися (або оброблятися) несподіваним або зловмисним способом при використанні, проходять санітизацію перед обробкою. | 2 |
| **1.3.11** | Перевірити, що застосунок санітизує введені користувачем дані перед передачею до поштових систем для захисту від SMTP- або IMAP-ін’єкцій. | 2 |
| **1.3.12** | Перевірити, що регулярні вирази не містять елементів, які викликають експоненціальний backtracking, а також забезпечити очищення недовірених вхідних даних для зменшення ризику атак типу ReDoS або Runaway Regex. | 3 |

## V1.4 Пам’ять, текстові рядки та некерований код

Наступні вимоги стосуються ризиків, пов’язаних із небезпечним використанням пам’яті, які зазвичай стосуються випадків, коли застосунок використовує системні мови програмування або некерований код.

В окремих випадках це можна досягти шляхом встановлення прапорців компілятора, які вмикають захист та попередження від переповнення буфера, включно з рандомізацією стека і забороною виконання даних, а також припиняють збірку, якщо виявляються небезпечні операції з покажчиками, пам’яттю, рядками форматування, цілими числами або текстовими рядками.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **1.4.1** | Перевірити, що застосунок використовує безпечні для пам’яті операції з текстовими рядками, безпечніші функції копіювання пам’яті та арифметику покажчиків для виявлення або запобігання переповненню стека, буфера або купи. | 2 |
| **1.4.2** | Перевірити, що застосовуються техніки для перевірки знаку, діапазону та валідації вхідних даних для запобігання переповненню цілих чисел. | 2 |
| **1.4.3** | Перевірити, що динамічно виділена пам’ять та ресурси звільняються, а посилання або покажчики на звільнену пам’ять видаляються або встановлюються в значення null для запобігання висячих покажчиків та вразливостей типу use-after-free. | 2 |

## V1.5 Безпечна десеріалізація

Перетворення даних із збереженого або переданого представлення у фактичні об’єкти застосунку (десеріалізація) історично було причиною численних вразливостей, пов’язаних із ін’єкцією коду. Важливо виконувати цей процес ретельно та безпечно, щоб уникнути подібних проблем.

Зокрема, деякі методи десеріалізації, визначені документацією мов програмування або фреймворків як небезпечні, не можуть бути безпечно використані з недовіреними даними. Для кожного механізму, що використовується, слід провести ретельну перевірку.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **1.5.1** | Перевірити, що застосунок налаштовує XML-парсери з обмеженою конфігурацією та вимикає небезпечні функції, такі як розв’язання зовнішніх сутностей, щоб запобігти атакам типу XML eXternal Entity (XXE). | 1 |
| **1.5.2** | Перевірити, що десеріалізація недовірених даних забезпечує безпечну обробку вхідних даних, наприклад, шляхом використання списку дозволених типів об’єктів або обмеження типів об’єктів, визначених клієнтом, для запобігання атакам десеріалізації. Механізми десеріалізації, які явно визначені як небезпечні, не повинні використовуватися з недовіреними вхідними даними. | 2 |
| **1.5.3** | Перевірити, що різні парсери, які використовуються у застосунку для одного типу даних (наприклад, JSON-парсери, XML-парсери, URL-парсери), виконують парсинг узгоджено та використовують однаковий механізм кодування символів, щоб уникнути проблем, таких як вразливості типу JSON Interoperability, або різної поведінки парсингу URI чи файлів, яку можуть використовувати в атаках типу Remote File Inclusion (RFI) або Server-side Request Forgery (SSRF). | 3 |

## Посилання

Для додаткової інформації дивіться також:

* [OWASP LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)
* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)
* [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
* [OWASP Web Security Testing Guide: Client-Side Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)
* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)
* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)
* [RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files](https://datatracker.ietf.org/doc/html/rfc4180#section-2)

Для додаткової інформації, зокрема щодо проблем десеріалізації або парсингу, дивіться:

* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
* [An Exploration of JSON Interoperability Vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)
* [Orange Tsai - A New Era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)
