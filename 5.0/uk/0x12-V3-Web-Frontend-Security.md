# V3 Безпека веб-фронтенду

## Мета контролю

Ця категорія зосереджена на вимогах, спрямованих на захист від атак, які здійснюються через веб-фронтенд. Ці вимоги не застосовуються до рішень типу "машина-до-машини".

## V3.1 Документація з безпеки веб-фронтенду

This section outlines the browser security features that should be specified in the application's documentation.
Ця секція описує особливості безпеки браузера, які мають бути вказані в документації застосунку.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.1.1** | Перевірити, що документація застосунку вказує на очікувані механізми безпеки, які мають підтримувати браузери, що використовують застосунок (наприклад, HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP) та інші відповідні HTTP-механізми безпеки). Також має бути визначено, як застосунок повинен поводитися у випадках відсутності деяких із цих механізмів (наприклад, попереджати користувача або блокувати доступ). | 3 |

## V3.2 Ненавмисне інтерпретування вмісту

Відображення вмісту або функціональності в неправильному контексті може призвести до виконання або відображення зловмисного контенту.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.2.1** | Перевірити, що впроваджено заходи безпеки, які запобігають відображенню браузером контенту або функціональності HTTP-відповідей у неправильному контексті (наприклад, при безпосередньому запиті до API, файлу, завантаженого користувачем, або іншого ресурсу). Можливі заходи можуть включати: не обслуговування контенту, якщо заголовки HTTP-запиту (такі як Sec-Fetch-\*) не вказують на правильний контекст; використання директиви sandbox у заголовку Content-Security-Policy; або тип attachment disposition у заголовку Content-Disposition. | 1 |
| **3.2.2** | Перевірити, що вміст, призначений для відображення як текст, а не для рендерингу як HTML, обробляється за допомогою безпечних функцій відображення (наприклад, createTextNode або textContent) для запобігання ненавмисному виконанню контенту, такого як HTML або JavaScript. | 1 |
| **3.2.3** | Перевірити, що застосунок запобігає DOM clobbering при використанні клієнтського JavaScript шляхом явного оголошення змінних, суворої перевірки типів, уникнення збереження глобальних змінних у об’єкті document та впровадження namespace isolation. | 3 |

## V3.3 Налаштування cookie

Цей розділ окреслює вимоги щодо безпечного налаштування чутливих cookies з метою забезпечення більш високого рівня впевненості, що вони створені саме самим застосунком, а також для запобігання витоку їх контенту або його неправомірній зміні.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.3.1** | Перевірити, що для cookies встановлено атрибут 'Secure', і якщо для імені cookie не використовується префікс '\__Host-', то обов’язково має використовуватися префікс '__Secure-'. | 1 |
| **3.3.2** | Перевірити, що значення атрибута 'SameSite' встановлено для кожного cookie відповідно до призначення цього cookie, щоб обмежити вплив атак на користувацький інтерфейс (user interface redress attacks) та браузерних атак типу підробки міжсайтових запитів (CSRF). | 2 |
| **3.3.3** | Перевірити, що cookie мають префікс '__Host-' в імені, якщо вони явно не призначені для спільного використання з іншими хостами. | 2 |
| **3.3.4** | Перевірити, що якщо значення cookie не повинно бути доступним для клієнтських скриптів (таких як токен сесії), то для такого cookie має бути встановлено атрибут 'HttpOnly', і це саме значення (наприклад, токен сесії) повинно передаватися клієнту лише через заголовок 'Set-Cookie'. | 2 |
| **3.3.5** | Перевірити, що при записі cookie сумарна довжина імені та значення cookie не перевищує 4096 байтів. Надто великі cookie не зберігатимуться браузером і, відповідно, не надсилатимуться із запитами, що призведе до неможливості користування функціоналом застосунку, який залежить від цього cookie. | 3 |

## V3.4 Заголовки механізмів безпеки браузера

У цьому розділі описано, які заголовки безпеки слід встановлювати у HTTP-відповідях для ввімкнення механізмів безпеки браузера та обмежень під час обробки відповідей від застосунку.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.4.1** | Перевірити, що у всіх відповідях встановлено заголовок Strict-Transport-Security для застосування політики HTTP Strict Transport Security (HSTS). Має бути визначено максимальний термін дії, а саме не менше одного року, а для рівня L2 і вище політика повинна поширюватися також на всі піддомени. | 1 |
| **3.4.2** | Перевірити, що заголовок Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin має фіксоване значення, встановлене застосунком, або, якщо використовується значення заголовка Origin HTTP-запиту, воно проходить перевірку за списком довірених джерел. Якщо потрібно використовувати 'Access-Control-Allow-Origin: *', то перевірити, що відповідь не містить жодної конфіденційної інформації. | 1 |
| **3.4.3** | Перевірити, що HTTP-відповіді містять заголовок Content-Security-Policy, який визначає директиви, що забезпечують завантаження та виконання браузером лише довіреного контенту або ресурсів, щоб обмежити виконання шкідливого JavaScript. Мінімально має бути використана глобальна політика, яка містить директиви object-src 'none' та base-uri 'none', а також визначає список дозволених ресурсів або використовує nonces чи хеші. Для застосунку рівня L3 має бути визначена політика на кожну відповідь з використанням nonces або хешів. | 2 |
| **3.4.4** | Перевірити, що всі HTTP-відповіді містять заголовок 'X-Content-Type-Options: nosniff'. Цей заголовок вказує браузерам не використовувати content sniffing та не вгадувати MIME-тип для наданої відповіді, а вимагати, щоб значення заголовка Content-Type відповідало типу запитуваного ресурсу. Наприклад, відповідь на запит стилю приймається лише якщо Content-Type відповіді має значення 'text/css'. Це також дозволяє браузеру використовувати функціонал Cross-Origin Read Blocking (CORB). | 2 |
| **3.4.5** | Перевірити, що застосунок встановлює referrer policy для запобігання витоку технічно чутливих даних до сторонніх сервісів через заголовок HTTP-запиту 'Referer'. Це може бути зроблено через HTTP-заголовок Referrer-Policy або через атрибути HTML-елементів. Чутливі дані можуть включати шлях та параметри запиту у URL, а для внутрішніх непублічних застосунків — також ім’я хоста. | 2 |
| **3.4.6** | Перевірити, що веб-застосунок у всіх HTTP-відповідях використовує директиву frame-ancestors у заголовку Content-Security-Policy, щоб за замовчуванням заборонити вбудовування конкретних ресурсів і дозволяти їх вбудовування лише у разі необхідності. Зверніть увагу, що заголовок X-Frame-Options, хоча й підтримується браузерами, але він є застарілим  і не повинен використовуватись як основний механізм захисту. | 2 |
| **3.4.7** | Перевірити, що заголовок Content-Security-Policy вказує адресу для надсилання звітів про порушення політики. | 3 |
| **3.4.8** | Перевірити, що всі HTTP-відповіді, які ініціюють рендеринг документа (такі як відповіді з Content-Type text/html), містять заголовок Cross-Origin-Opener-Policy з директивою same-origin або same-origin-allow-popups за потребою. Це запобігає атакам, які зловживають спільним доступом до об’єктів Window, таким як tabnabbing та frame counting. | 3 |

## V3.5 Розділення походжень у браузері

Під час обробки запитів до чутливої функціональності на серверній стороні, застосунок повинен переконатися, що запит було ініційовано самим застосунком або довіреною стороною, а не підроблено зловмисником.

Під чутливою функціональністю в даному контексті мається на увазі, зокрема, обробка форм для автентифікованих і неавтентифікованих користувачів (наприклад, запит на автентифікацію), операції, що змінюють стан, або функціональність, що створює значне навантаження на ресурси, як-от експорт даних.

Ключовими засобами захисту у цьому випадку є політики безпеки браузера, зокрема Політика однакового походження для JavaScript, а також логіка SameSite для cookies. Ще одним поширеним механізмом захисту є CORS preflight. Цей механізм є критично важливим для кінцевих точок, призначених для виклику з іншого джерела, але також може ефективно запобігати підробленим запитам і у випадках, коли виклики з іншого джерела не передбачено.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.5.1** | Перевірити, що якщо застосунок не покладається на механізм CORS preflight для запобігання забороненим крос-доменним запитам до використання чутливої функціональності, то такі запити мають пройти перевірку, щоб переконатися, що вони дійсно походять від самого застосунку. Це може бути реалізовано шляхом використання й перевірки anti-forgery токенів або вимогою наявності додаткових HTTP-заголовків, які не входять до списку CORS-safelisted заголовків запиту. Це необхідно для захисту від атак типу Cross-Site Request Forgery (CSRF), що базуються на підроблених запитах з боку браузера. | 1 |
| **3.5.2** | Перевірити, що якщо застосунок покладається на механізм CORS preflight для запобігання забороненим крос-доменним запитам до використання чутливої функціональності, то не повинна бути можливість для виклику цієї функціональністі за допомогою запиту, який не запускає CORS preflight. Для цього може знадобитися перевірка значень заголовків запиту 'Origin' та 'Content-Type' або вимогою наявності додаткових HTTP-заголовків, які не входять до списку CORS-safelisted заголовків запиту. | 1 |
| **3.5.3** | Перевірити, що HTTP-запити до чутливої функціональності використовують відповідні HTTP-методи, такі як POST, PUT, PATCH або DELETE, а не методи, визначені в HTTP-специфікації як "безпечні", наприклад HEAD, OPTIONS або GET. Як альтернативу, можна застосувати сувору перевірку заголовків запиту Sec-Fetch-*, щоб упевнитися, що запит не був ініційований у результаті небажаного крос-доменного виклику, навігаційного запиту або завантаження ресурсу (такого як зображення), де цього не очікують. | 1 |
| **3.5.4** | Перевірити, що окремі застосунки розміщені на різних іменах хостів, щоб скористатися обмеженнями, які накладає Політика того ж походження (Same-Origin Policy), включаючи такі аспекти, як те, як документи або скрипти, що завантажені з одного походження, можуть взаємодіяти з ресурсами з іншого походження, а також обмеження на cookies, що базуються на імені хоста. | 2 |
| **3.5.5** | Перевірити, що повідомлення, отримані через інтерфейс postMessage, ігноруються, якщо походження повідомлення не є довіреним або якщо синтаксис повідомлення недійсний. | 2 |
| **3.5.6** | Перевірити, що функціональність JSONP не ввімкнена в жодній частині застосунку, щоб уникнути атак Cross-Site Script Inclusion (XSSI). | 3 |
| **3.5.7** | Перевірити, що дані, які потребують авторизації, не включаються у відповіді з ресурсами скриптів, такими як JavaScript-файли, щоб запобігти атакам Cross-Site Script Inclusion (XSSI). | 3 |
| **3.5.8** | Перевірити, що автентифіковані ресурси (такі як зображення, відео, скрипти та інші документи) можуть завантажуватись або вбудовуватись від імені користувача лише за умови, що це є очікуваною дією. Це може бути досягнуто шляхом суворої перевірки значень HTTP-заголовків Sec-Fetch-*, щоб упевнитися, що запит не надійшов у результаті небажаного крос-доменного виклику, або ж через встановлення обмежувального заголовка відповіді Cross-Origin-Resource-Policy, який вказує браузеру блокувати отриманий вміст. | 3 |

## V3.6 Цілісність зовнішніх ресурсів

Ця секція містить рекомендації щодо безпечного використання контенту, розміщеного на сторонніх сайтах.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.6.1** | Перевірити, що клієнтські ресурси, такі як JavaScript-бібліотеки, CSS або веб-шрифти, розміщуються на зовнішніх ресурсах (наприклад, на Content Delivery Network) лише у випадку, якщо цей ресурс є статичним, має версіонування та використовує механізм перевірки цілісності підресурсів (Subresource Integrity, SRI). Якщо це неможливо, має існувати задокументоване обґрунтоване рішення з безпеки для кожного такого ресурсу. | 3 |

## V3.7 Інші міркування щодо безпеки браузера

У цьому розділі розглядаються додаткові механізми захисту та сучасні можливості безпеки браузерів, які є необхідними для забезпечення клієнтської безпеки на стороні браузера.

| # | Опис | Рівень |
| :---: | :--- | :---: |
| **3.7.1** | Перевірити, що застосунок використовує лише ті клієнтські технології, які наразі підтримуються та вважаються безпечними. Прикладами застарілих або небезпечних технологій, що не відповідають цій вимозі, є: NSAPI-плагіни, Flash, Shockwave, ActiveX, Silverlight, NACL або клієнтські Java-аплети. | 2 |
| **3.7.2** | Перевірити, що застосунок автоматично перенаправляє користувача на інший хост або домен (який не контролюється самим застосунком) лише у випадках, коли відповідна адреса-призначення внесена до списку дозволених адрес-призначень. | 2 |
| **3.7.3** | Перевірити, що застосунок відображає нотифікацію під час перенаправлення користувача на URL-адресу, яка не знаходиться під контролем застосунку, із можливістю скасувати перехід. | 3 |
| **3.7.4** | Перевірити, що домен верхнього рівня застосунку (наприклад, site.tld) додано до публічного попереднього списку (preload list) для політики HTTP Strict Transport Security (HSTS). Це гарантує, що використання TLS вбудоване безпосередньо в основні браузери, а не буде базуватись лише на заголовку Strict-Transport-Security. | 3 |
| **3.7.5** | Перевірте, що застосунок поводиться згідно з документацією (наприклад, попереджає користувача або блокує доступ), якщо браузер, який використовується для доступу, не підтримує очікувані механізми безпеки. | 3 |

## Посилання

Для додаткової інформації дивіться також:

* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes)
* [OWASP Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)
* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)
* [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
* [HSTS Browser Preload List submission form](https://hstspreload.org/)
* [OWASP DOM Clobbering Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_Clobbering_Prevention_Cheat_Sheet.html)
